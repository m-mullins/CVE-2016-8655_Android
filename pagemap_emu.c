#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <dlfcn.h>
#include <sys/wait.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <linux/if_packet.h>
#include <pthread.h>
#include <linux/sched.h>
#include <netinet/tcp.h>
#include <sys/syscall.h>
#include <signal.h>
#include <sched.h>
#include <sys/utsname.h>
#include <pthread.h>
#include <time.h>
#include <sys/time.h>
#include <sys/types.h>
#include <signal.h>
#include <semaphore.h>

sem_t sem;
void* glb_addr;
int glb_pfn;

void* makemap()  {
    void* addr = mmap(NULL,getpagesize(), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    //read_pagemap(addr); test worked, page was not present until written too
    if (addr) {
        memset(addr, 0x43, getpagesize());
    }
    return addr;
}

#define PAGEMAP_ENTRY 8
#define GET_BIT(X,Y) (X & ((uint64_t)1<<Y)) >> Y
#define GET_PFN(X) X & 0x7FFFFFFFFFFFFF
#define KERNEL_BOUNDARY 0xC0000000

const int __endian_bit = 1;
#define is_bigendian() ( (*(char*)&__endian_bit) == 0 )

int read_pagemap(unsigned long virt_addr){
    int i, c, pid, status;
    uint64_t read_val, file_offset;
    FILE * f;
    char *end;

   printf("Big endian? %d\n", is_bigendian());
   f = fopen("/proc/self/pagemap", "rb");
   if(!f){
      printf("Error! Cannot open %s\n", "/proc/self/map");
      return -1;
   }
   
   //Shifting by virt-addr-offset number of bytes
   //and multiplying by the size of an address (the size of an entry in pagemap file)
   file_offset = virt_addr / getpagesize() * PAGEMAP_ENTRY;
   printf("Vaddr: 0x%lx, Page_size: %d, Entry_size: %d\n", virt_addr, getpagesize(), PAGEMAP_ENTRY);
   printf("Reading at 0x%llx\n",  (unsigned long long) file_offset);
   status = fseek(f, file_offset, SEEK_SET);
   if(status){
      perror("Failed to do fseek!");
      return -1;
   }
   errno = 0;
   read_val = 0;
   unsigned char c_buf[PAGEMAP_ENTRY];
   for(i=0; i < PAGEMAP_ENTRY; i++){
      c = getc(f);
      if(c==EOF){
         printf("\nReached end of the file\n");
         return 0;
      }
      if(is_bigendian())
           c_buf[i] = c;
      else
           c_buf[PAGEMAP_ENTRY - i - 1] = c;
      printf("[%d]0x%x ", i, c);
   }
   for(i=0; i < PAGEMAP_ENTRY; i++){
      //printf("%d ",c_buf[i]);
      read_val = (read_val << 8) + c_buf[i];
   }
   printf("\n");
   printf("Result: 0x%llx\n", (unsigned long long) read_val);
   //if(GET_BIT(read_val, 63))
   if(GET_BIT(read_val, 63)) {
      //printf("PFN: 0x%llx %d\n",(unsigned long long) GET_PFN(read_val),(unsigned long long) GET_PFN(read_val));
      fclose(f);
      return (unsigned long long) GET_PFN(read_val);
      
   } else {
      printf("Page not present\n");
   }
   if(GET_BIT(read_val, 62)) {
      printf("Page swapped\n");
   }
   fclose(f);
   return 0;
}

void* threadedmaps() {
    int boundary = KERNEL_BOUNDARY/getpagesize();
    int value,res;
    void* addr = 0;
    void* addrs[1024];
    memset(addrs, 0, 1024);
    int count = 0;
    for(count = 0; count < 1024; ++count) {
        sem_getvalue(&sem, &value);
        if (value != 0) { break; }
        addr = makemap();
        addrs[count] = addr;
        res = read_pagemap((unsigned long)addr);
        if (res < boundary) {
            glb_pfn = res;
            glb_addr = addr;
            sem_post(&sem);
            break;
        }
    }
    for(;;) {
        sem_getvalue(&sem, &value);
        if (value != 0) { break; }
        sleep(1);
    }
    for(count = 0; count < 1024; ++count) {
        if (addrs[count]) {
            munmap(addrs[count],getpagesize());
        }
    }
    pthread_exit(NULL);
}

#define THREAD_COUNT 1
int main(int argc, char** argv) {
    glb_addr = 0;
    glb_pfn = 0;
    sem_init(&sem, 0, 0);
    pthread_t th[THREAD_COUNT];
    int k;

    for (k = 0; k < THREAD_COUNT; k++) {
        pthread_create(&th[k], NULL, threadedmaps, NULL);
    }

    while (sem_wait(&sem)!=0) {}

    for (k = 0; k < THREAD_COUNT; ++k) {
        pthread_join(th[k],NULL);
    }
    //void* addr = makemap();
    //printf("vaddr = %p\n",addr);
    //int res = read_pagemap((unsigned long)addr);
    //sleep(31337);
    int boundary = KERNEL_BOUNDARY/getpagesize();
    printf(" v: %p p: %d b: %d\n", glb_addr, glb_pfn, boundary);
    fflush(stdout);

    return 0;
}
